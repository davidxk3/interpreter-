/* Generated By:JavaCC: Do not edit this line. HLEval.java Version 7.0.9 */
public class HLEval implements HLVisitor{
  public Object defaultVisit(SimpleNode node, Object data) throws Exception{
    node.childrenAccept(this, data);
    return data;
  }
  public Object visit(SimpleNode node, Object data) throws Exception{
    return defaultVisit(node, data);
  }
  public Object visit(ASTbody node, Object data) throws Exception{
    return defaultVisit(node, data);
  }
  public Object visit(ASTclause node, Object data) throws Exception{
    return defaultVisit(node, data);
  }

  // Added to symbol table in scanning, don't have to evaluate anything here 
  public Object visit(ASTvar_decl node, Object data) throws Exception{
 	return defaultVisit(node, data);
  }
  public Object visit(ASTfn_decl node, Object data) throws Exception{
    return defaultVisit(node, data);
  }
  public Object visit(ASTident_list node, Object data) throws Exception{
    return defaultVisit(node, data);
  }
  public Object visit(ASTfn_call node, Object data) throws Exception{
    return defaultVisit(node, data);
  }
  public Object visit(ASTboolean_call node, Object data) throws Exception{
    return defaultVisit(node, data);
  }
  public Object visit(ASTvalue_list node, Object data) throws Exception{
    return defaultVisit(node, data);
  }
  public Object visit(ASTReturn node, Object data) throws Exception{
    return defaultVisit(node, data);
  }
  public Object visit(ASTAssign node, Object data) throws Exception{
    return defaultVisit(node, data);
    // first child is identifier name, second child is expression value, evaluate
  }
// 6Cb: Just print its child WITHOUT new line 
  public Object visit(ASTPrint node, Object data) throws Exception{
  	String val = ((String) node.jjtGetChild(0).jjtAccept(this, data));
	System.out.print(val);
	return null;
  }
// 6Cb: Just print its child WITH new line 
  public Object visit(ASTPrintln node, Object data) throws Exception{
    	String val = ((String) node.jjtGetChild(0).jjtAccept(this, data));
	System.out.println(val);
	return null;
  }
// 6Cb: part of print and println statements -> children can be HLNumber, Strings, or Booleans 
  public Object visit(ASTprint_list node, Object data) throws Exception{
	// initialize output string 
	String list = "";
	for (int i = 0; i < node.jjtGetNumChildren(); i++) {
		// add each child (parameter) to list (string output) by accepting visitor 
		list += node.jjtGetChild(i).jjtAccept(this, data);
	}

	return list; 
  }
// 6Cb: If statement -> return one of the following: HLNumber or String or Boolean 
  public Object visit(ASTIf node, Object data) throws Exception{
	// Variable used to check if we should skip the next clause, default to null
	boolean skipClause = false;
	
	for (int i = 0; i < node.jjtGetNumChildren(); i++) {
		// If we should skip the next clause because the previous clause was false 
		if (skipClause) {
			// Don't skip next clause
			skipClause = false;
			continue;
		}

		// Evaluate current child 
		Object currentChild = node.jjtGetChild(i).jjtAccept(this, data); 		
		
		// Make sure a child isn't null, otherwise if it's null return itself
		if (currentChild == null) {
			return null;
		}

		// if it's TRUE
		if ((currentChild instanceof Boolean) && ((boolean) currentChild)) {
			// We return the NEXT child (which will be the clause because of how ASTIf is structured)
			return node.jjtGetChild(i+1).jjtAccept(this, data);
		// if it's FALSE (nothing happens)
		} else if ((currentChild instanceof Boolean) && !((boolean) currentChild)) {
			// Skip 
			skipClause = true;	
			continue;
		// Else, if there is a clause, means we have reached the (else statement)
		} else {
			// This child is a CLAUSE (else)
			return currentChild;
		}
	}
	// Else if nothing is true, just return defaultVisit
	return defaultVisit(node, data);
  }
  public Object visit(ASTNULL node, Object data) throws Exception{
    return defaultVisit(node, data);
  }
  public Object visit(ASTFor node, Object data) throws Exception{
    return defaultVisit(node, data);
  }
  public Object visit(ASTexp_list node, Object data) throws Exception{
    return defaultVisit(node, data);
  }
  public Object visit(ASTWhile node, Object data) throws Exception{
    return defaultVisit(node, data);
  }
// 6Ba: Boolean expression (OR) -> Boolean (expressed in Java as specified)
  public Object visit(ASTor node, Object data) throws Exception{
	// Assume boolean is FALSE until its true 
	boolean result = false;	
	// Has arbitrary children, just evaluate them all
	for (int i = 0; i < node.jjtGetNumChildren(); i++) {
		result = result || ((boolean) node.jjtGetChild(i).jjtAccept(this, data));
		// if it's true, no point checking the rest since its OR
		if (result) {
			return true;
		}
	}
	// if it's still false after evaluating all its children, then return false
	return false;
  }
// 6Ba: Boolean expression (AND) -> Boolean (expressed in Java as specified)
  public Object visit(ASTand node, Object data) throws Exception{
  	// Assume boolean is TRUE until its false 
	boolean result = true;
	// Has arbitrary children, just evaluate them all	
	for (int i = 0; i < node.jjtGetNumChildren(); i++) {
		result = result && ((boolean) node.jjtGetChild(i).jjtAccept(this, data));
		// if it's false, no point checking the rest since its AND 
		if (!result) {
			return false;
		}
	}

	// if it's still true after evaluating all its children, then return true
	return true;
  }
// 6Ba: Boolean expression (NOT) -> Boolean (expressed in Java as specified)
  public Object visit(ASTnot node, Object data) throws Exception{
    	// We know that ASTnot will have ONE child which will be of type Boolean
	// Let evaluate visitor visit child and then apply NOT to result
	return !((boolean) node.jjtGetChild(0).jjtAccept(this, data));
  }
// 6Cb: BOOLEAN LITERAL -> can evaluate to Java booleans
  public Object visit(ASTTRUE node, Object data) throws Exception{
	return true;
  }
// 6Cb: BOOLEAN LITERAL -> can evaluate to Java booleans 
  public Object visit(ASTFALSE node, Object data) throws Exception{
 	return false;
  }
// 6Ba: Comparison with NUMBER operands -> BOOLEAN (use Java boolean as specified)
// 6Ab: Comparison with sets -> BOOLEAN (use Java boolean as specified)
  public Object visit(ASTcomparison node, Object data) throws Exception{
	// There is always exactly three children: operand1, comparison, operand2
	// We know the structure as the visitor
	// Two operands as first and third child respectively which are NUMBER/SET operands with respect to 6Ba
	HLObject operand1 = ((HLObject) node.jjtGetChild(0).jjtAccept(this, data));
	HLObject operand2 = ((HLObject) node.jjtGetChild(2).jjtAccept(this, data));

	String operation = ((String) node.jjtGetChild(1).jjtAccept(this, data));

	// String of SimpleNode to find out what comparison is being made 
	// Check to see what comparison is being made
	switch(operation) {
		// Call methods made in HLNumber
		case "<":
			return operand1.isLessThan(operand2);
		case "<=":
			return operand1.isSame(operand2) || operand1.isLessThan(operand2);
		case ">":
			// have to check whether its set or num since order matters for set
			if (operand1 instanceof HLNumber ) {
				return !operand1.isLessThan(operand2) && !operand1.isSame(operand2);
			} else {
				return operand2.isLessThan(operand1) && !operand2.isSame(operand1);
			}
		case ">=":
			// have to check whether its set or num since order matters for set
			if (operand1 instanceof HLNumber) {
				return operand1.isSame(operand2) || !(operand1.isLessThan(operand2));
			} else {
				return operand2.isSame(operand1) || operand2.isLessThan(operand1);
			}
		case "==":
			return operand1.isSame(operand2);
		case "!=":		
			return !(operand1.isSame(operand2));	
		case "=in":
			if (operand1 instanceof HLNumber && operand2 instanceof HLSet) {
				return ((HLSet) operand2).contains(operand1);
			}
		case "!=in":
			if (operand1 instanceof HLNumber && operand2 instanceof HLSet) {
				return !(((HLSet) operand2).contains(operand1));
			}
		default:
			break;
	}
	// If the operation isn't one of the above, then return defaultVisit
	return defaultVisit(node, data);
  }
// 6Ba: Following are comparison operators, we return their STRING LITERAL equivalent (evalauted to Java strings)
  public Object visit(ASTLESS node, Object data) throws Exception{
	return "<";
  }
  public Object visit(ASTLESSEQ node, Object data) throws Exception{
	return "<=";
  }
  public Object visit(ASTGREATER node, Object data) throws Exception{
	return ">";
  }
  public Object visit(ASTGREATEQ node, Object data) throws Exception{
	return ">=";
  }
  public Object visit(ASTEQUAL node, Object data) throws Exception{
	return "==";
  }
  public Object visit(ASTNOTEQ node, Object data) throws Exception{
	return "!=";
  }
  public Object visit(ASTISIN node, Object data) throws Exception{
	return "=in";
  }
  public Object visit(ASTNOTIN node, Object data) throws Exception{
	return "!=in";
  }
// 6Cb: ARITHMETIC EXPRESSIONS involving integers (numbers) -> HLNumber
// 6Ab: SET OPERATION involving sets -> HLSet (set union)
  public Object visit(ASTsum node, Object data) throws Exception{
	// HLObject to be returned
	HLObject result;

	// Check if it's HLNumber
	if (node.jjtGetChild(0).jjtAccept(this, data) instanceof HLNumber) {
		result = new HLNumber(0);
	// Else, it's a HLSet
	} else {
		result = new HLSet();
	}

 	// iterate through children and add (OR SUBTRACT if child is ASTneg)
	for (int i = 0; i < node.jjtGetNumChildren(); i++) {
		// if working with SETS (subtraction with HLSets is different from HLNumbers) and its child is neg 
		if ((node.jjtGetChild(i).jjtAccept(this, data) instanceof HLSet) && node.jjtGetChild(i).toString().equals("neg")) {
			// if parent node only has one children, then we apply unary operator - (keep changes from visitor to neg)
			if (node.jjtGetNumChildren() == 1) {
				result = result.add((HLObject) node.jjtGetChild(i).jjtAccept(this, data));
				continue;
			// else, we are doing set difference (reverse changes from visitor to neg)
			} else {
				result = result.sub(((HLObject) node.jjtGetChild(i).jjtAccept(this, data)).negate());
			}
		// else, working with HLNumbers (or addition for sets)
		} else {
			result = result.add((HLObject) node.jjtGetChild(i).jjtAccept(this, data));
		}
	}
	return result;
  }
// 6Cb: ARITHMETIC EXPRESSION involving integers (number) -> HLNumber
// 6Ab: SET OPERATION involving set -> HLSet
  public Object visit(ASTneg node, Object data) throws Exception{
	// Has one child which is an identifier, just multiply its value by (-1) or - unary operator for sets
	return ((HLObject) node.jjtGetChild(0).jjtAccept(this, data)).negate();
  }
// 6Cb: ARITHMETIC EXPRESSION involving integers (number) -> HLNumber
// 6Ab: SET OPERATION involving set -> HLSet
  public Object visit(ASTpos node, Object data) throws Exception{
	// Has one child which is an identifier, just return the same value of its child (which is positive)
	return node.jjtGetChild(0).jjtAccept(this, null);
  }
// 6Cb: ARITHMETIC EXPRESSION involving integers (number) -> HLNumber
// 6Ab: SET OPERATION involving set -> HLSet
  public Object visit(ASTmul node, Object data) throws Exception{
	// There is always EXACTLY two children so just return child 1 (HLNumber) multiplied by child 2 (HLNumber)
	HLObject child1 = ((HLObject) node.jjtGetChild(0).jjtAccept(this, data));
	HLObject child2 = ((HLObject) node.jjtGetChild(1).jjtAccept(this, data));
	return child1.mul(child2);
  }
// 6Cb: ARITHMETIC EXPRESSION involving integers (number) -> HLNumber
// 6Ab: Set OPERATION involving set -> HLSet
  public Object visit(ASTdiv node, Object data) throws Exception{
	// Same thing as ASTmul, always exactly two children, only difference is you call div method instead
    	HLNumber child1 = ((HLNumber) node.jjtGetChild(0).jjtAccept(this, data));
	HLNumber child2 = ((HLNumber) node.jjtGetChild(1).jjtAccept(this, data));
	return child1.div(child2);
  }
// 6Cb: ARITHMETIC EXPRESSION involving integers (number) -> HLNumber
  public Object visit(ASTmod node, Object data) throws Exception{
	// Same thing as ASTmul, always exactly two children, only difference is you call mod method instead
  	HLNumber child1 = ((HLNumber) node.jjtGetChild(0).jjtAccept(this, data));
        HLNumber child2 = ((HLNumber) node.jjtGetChild(1).jjtAccept(this, data));
	return child1.mod(child2);
  }
// 6Cb: ARITHMETIC EXPRESSION involving integers (numbers) -> HLNumber
// 6Ab: SET OPERATIONS involving set -> HLNumber 
  public Object visit(ASTAbsolute_value node, Object data) throws Exception{
	// Return its card() method
	// 6Cb: For a HLNumber, it is the absolute value of the HLNumber
	// 6Ab: For a HLSet, it is the length of the HLSet
	// It has ONLY one child so we evaluate it 
	Object child_evaluated = node.jjtGetChild(0).jjtAccept(this, data);

	if (child_evaluated instanceof HLNumber) {
		return ((HLNumber) child_evaluated).card();
	}
	return ((HLSet) child_evaluated).card();
  }
// 6Ab: Given an ASTInterval -> HLSet
  public Object visit(ASTinterval node, Object data) throws Exception{
	// Interval will have EXACTLY two children representing left and right bound - we know structure
	// After sending evaluate visitor to its children, they will return HLNumbers
	HLNumber left_bound = ((HLNumber) node.jjtGetChild(0).jjtAccept(this, data));
	HLNumber right_bound = ((HLNumber) node.jjtGetChild(1).jjtAccept(this, data));

	// Create new HLSet with those intervals
	HLSet set = new HLSet(left_bound, right_bound);
	// Return set as HLSet
	return set;
  }
  public Object visit(ASTset_former node, Object data) throws Exception{
    return defaultVisit(node, data);
  }
// 6Ba: Set literals -> HLSet
  public Object visit(ASTset node, Object data) throws Exception{
	HLSet set = new HLSet();
	// Iterate through its children and manually add them to HLSet
	for (int i = 0; i < node.jjtGetNumChildren(); i++) {
		// Children accept evaluate visitor and its evaluation is added to set
		// Since HLSet can only contain HLNumber, we typecast Object (initially an int) to HLNumber
		set.addToSet((HLNumber) node.jjtGetChild(i).jjtAccept(this, data));
	}
	
	// Return the set as HLSet
	return set;
  }
  // identifier uses key stored in its token to print value of identifier 
  public Object visit(ASTidentifier node, Object data) throws Exception {
	return HLSymbTab.retrieveValue(((IdentifierToken) node.jjtGetValue()).getKey());
  }
  public Object visit(ASTtypenum node, Object data) throws Exception{
	return defaultVisit(node, data);
  }
  public Object visit(ASTtypeset node, Object data) throws Exception{
	// return defaultVisit(node, data);
	return "typeset";
  }
// 7Cb: Typebool identifier (IdBoolToken)
  public Object visit(ASTtypebool node, Object data) throws Exception{
    	// return defaultVisit(node, data);
	return "typebool";
  }
// 6Cb: NUMBER LITERAL -> HLNumber with a value 
  public Object visit(ASTnumber node, Object data) throws Exception{
	// Have to type cast to integer from Object 
	HLNumber number = new HLNumber((int) node.jjtGetValue());
	return number;
  }
// 6Cb: STRING LITERAL -> can evaluate to Java String equivalent 
  public Object visit(ASTstring node, Object data) throws Exception{
    	
	return node.jjtGetValue();
  }
}
/* JavaCC - OriginalChecksum=5fed741071bb7da1c3cb2cfb13af7ff9 (do not edit this line) */
